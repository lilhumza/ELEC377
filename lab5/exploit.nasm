          bits 64
            ; find out where we are
            ; your code starts here
start:      xor rax, rax

            ; put name of command to run on stack
            ; push 0 - clearing register results in zero value
            push rax
            ; push '/bin/env'
            xor rax, rax
            mov rax, '/bin/env'
            push rax

            ; put address of command in rdi
            mov rdi, rsp

            ; create the argv array
            ; push 0
            xor rax, rax
            push rax
            push rdi

            ; put the address of the argv array in rsi
            mov rsi, rsp

            ; environ address 0x7ffff7fbe600
            ; clear the rdx register
            xor rdx, rdx
            ; load 0x7fff into low 16 bits of rdx (dx)
            mov dx, 0x7fff
            ; left shift the rdx register by 32 bits
            shl rdx, 32
            ; load 0xf7fbe600 into low 32 bits of rcx (ecx)
            mov ecx, 0xf7fbe6ff
            ; clear low 8 bits of rcx (cl)
            xor cl, cl
            ; combine registers using or
            or rdx, rcx
            ; load rdx with memory pointed by rdx
            mov rdx, [rdx]

            ; set up system call
            xor rax, rax
            mov al, 0x3B
            syscall

            ; exit system call
            mov al, 0x3c
            mov rdi, rax
            syscall

            ; space for data so stack
            ; does not overflow the code
            dq 0xffffffffffffffff
            dq 0xffffffffffffffff
            dq 0xffffffffffffffff
            dq 0xffffffffffffffff
            dq 0xffffffffffffffff
end:        dd end-start

; rdi is the path to command to be executed -> "/bin/env"
; rsi is the pointer to the argv array adress -> argv[0] is name of command
; rdx is the pointer to environment array address -> "0x7ffff7fbe600"
